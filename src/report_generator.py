#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Report Generator - Report Generator (Enhanced for Camera Integration)
Generate English fire risk assessment technical reports, supports JSON format
"""

import json
import os
from datetime import datetime
from typing import List, Dict, Optional
import logging

logger = logging.getLogger(__name__)

class ReportGenerator:
    """Report Generator Class - Report Generator Class (Enhanced)"""
    
    def __init__(self, output_dir: str = "reports"):
        """
        Initialize report generator
        
        Args:
            output_dir: Report output directory
        """
        self.output_dir = output_dir
        
        # Create output directory (if it doesn't exist)
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)
            logger.info(f"Created report directory: {output_dir}")
    
    def generate_technical_report(self, assessment_result: Dict, model_name: str = "gpt-4o-mini") -> Dict:
        """
        Generate technical-style fire risk assessment report
        
        Args:
            assessment_result: AI assessment result (including raw data and AI analysis)
            model_name: AI model name used
            
        Returns:
            Formatted technical report dictionary
        """

        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')
        
        # Extract data
        sensor_data = assessment_result.get('sensor_data', {})
        ai_assessment = assessment_result.get('ai_assessment', {})
        location = sensor_data.get('location', {})
        coordinates = location.get('coordinates', {})
        camera_assessment = sensor_data.get('camera_assessment', {})
        weather = sensor_data.get('weather', {})
        fire_risk_data = sensor_data.get('fire_risk_data', {})
        fire_stations = sensor_data.get('fire_stations', {})
        
        # Build technical report
        report = {
            "report_header": {
                "title": "FIRE RISK ASSESSMENT REPORT",
                "generation_time": timestamp,
                "ai_model": model_name,
                "report_id": f"FRA_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            },
            
            "disclaimer": {
                "warning": "IMPORTANT: This fire risk assessment is generated by an AI system for informational purposes only.",
                "limitations": [
                    "This assessment is based on available sensor data and weather information at the time of analysis",
                    "AI-generated recommendations should be verified by qualified fire safety professionals",
                    "Real-time conditions may differ from the data used in this assessment",
                    "This system is not a substitute for professional fire safety judgment"
                ],
                "liability": "Users are responsible for verifying information and making final decisions regarding fire safety actions",
                "emergency_notice": "In case of immediate fire danger, contact emergency services (911) immediately regardless of this assessment"
            },
            
            "executive_summary": {
                "risk_level": ai_assessment.get('risk_level', 'Unknown'),
                "risk_score": f"{ai_assessment.get('risk_score', 0)}/5",
                # Ensure risk_level and risk_score are consistent
                "location": location.get('county', 'Unknown'),
                "assessment_time": timestamp
                # "confidence": ai_assessment.get('confidence', 'Unknown')
            },

            # Dynamically get KumoRFM data (handle numpy types)
            "kumo_prediction": self._process_kumo_prediction(assessment_result.get('kumo_prediction', {})),
            
            "location_information": {
                "coordinates": {
                    "latitude": f"{coordinates.get('lat', 0):.6f}째N",
                    "longitude": f"{abs(coordinates.get('lon', 0)):.6f}째W"
                },
                "administrative": {
                    "city": location.get('city', 'Unknown'),
                    "county": location.get('county', 'Unknown'),
                    "state": "California"
                },
                "geographic": {
                    "land_type": location.get('land_type', 'Unknown'),
                    "grid_point": location.get('nearest_grid_point', 'Unknown'),
                    "display_name": location.get('display_name', 'Unknown')
                }
            },
            
            "camera_detection_analysis": self._format_camera_analysis(camera_assessment),
            
            "weather_conditions": self._format_weather_data(weather),
            
            "fire_risk_assessment": {
                "fhsz_classification": {
                    "risk_level": fire_risk_data.get('fhsz_risk', 'Unknown'),
                    "description": fire_risk_data.get('fhsz_risk_level', 'Unknown')
                },
                "historical_fire_data": self._format_fire_history(fire_risk_data),
                "ai_risk_analysis": {
                    "assessment": ai_assessment.get('reasoning', 'No analysis available'),
                    # "confidence_level": ai_assessment.get('confidence', 'Unknown'),
                    "risk_factors": self._extract_risk_factors(ai_assessment.get('reasoning', ''))
                }
            },
            
            "emergency_recommendations": {
                "immediate_actions": assessment_result.get('emergency_recommendations', []),
                "monitoring_requirements": assessment_result.get('monitoring_recommendations', []),  # Use ai
                "resource_deployment": self._generate_resource_recommendations(ai_assessment.get('risk_score', 0), fire_stations)
            },
            
            "fire_station_resources": self._format_fire_stations(fire_stations),
            
            "technical_metadata": {
                "data_sources": {
                    "camera_data": f"{camera_assessment.get('total_cameras', 0)} cameras",
                    "weather_source": weather.get('source', 'Unknown'),
                    "geographic_database": "California Fire Risk Enhanced Dataset"
                },
                "processing_details": {
                    "cluster_id": sensor_data.get('cluster_id', 'Unknown'),
                    # "detection_confidence": camera_assessment.get('detection_confidence', 'Unknown'),
                    "grid_point_match": "Nearest neighbor algorithm"
                }
            }
        }
        
        return report

    def _process_kumo_prediction(self, kumo_data: Dict) -> Dict:
      """Process KumoRFM data, convert numpy types to Python native types"""
      if not kumo_data:
          return {}
      
      processed = {}
      for key, value in kumo_data.items():
          if hasattr(value, 'item'):  # numpy type
              processed[key] = value.item()  # Convert to Python native type
          else:
              processed[key] = value
      
      return processed
    
    def _format_camera_analysis(self, camera_data: Dict) -> Dict:
        """Format camera analysis data"""
        return {
            "deployment_summary": {
                "total_cameras": camera_data.get('total_cameras', 0),
                "cluster_radius": "500 meters",
                "camera_ids": camera_data.get('camera_ids', [])
            },
            "detection_status": {
                "fire_detections": f"{camera_data.get('cameras_detecting_fire', 0)}/{camera_data.get('total_cameras', 0)} cameras",
                "smoke_detections": f"{camera_data.get('cameras_detecting_smoke', 0)}/{camera_data.get('total_cameras', 0)} cameras",
                "normal_status": f"{camera_data.get('cameras_normal', 0)}/{camera_data.get('total_cameras', 0)} cameras"
            },
            "detection_rates": {
                "fire_detection_rate": f"{camera_data.get('fire_detection_rate', 0):.1%}",
                "smoke_detection_rate": f"{camera_data.get('smoke_detection_rate', 0):.1%}"
            },
            "assessment": {
                "primary_status": camera_data.get('primary_detection_status', 'normal'),
                # "confidence_level": camera_data.get('detection_confidence', 'Unknown'),
                "detection_summary": camera_data.get('detection_summary', 'No detection data available')
            }
        }
    
    def _format_weather_data(self, weather: Dict) -> Dict:
        """Format weather data"""
        temp = weather.get('temperature', {})
        wind = weather.get('wind_speed', {})
        
        return {
            "temperature": {
                "fahrenheit": f"{temp.get('fahrenheit', 'N/A')}째F",
                "celsius": f"{temp.get('celsius', 'N/A')}째C"
            },
            "humidity": f"{weather.get('humidity', 'N/A')}%",
            "wind_speed": {
                "mph": f"{wind.get('mph', 'N/A')} mph",
                "mps": f"{wind.get('mps', 'N/A')} m/s"
            },
            "conditions": weather.get('weather_description', 'Unknown'),
            "data_source": weather.get('source', 'Unknown')
        }
    
    def _format_fire_history(self, fire_history: Dict) -> Dict:
        """Format fire history data"""
        return {
            "total_incidents": fire_history.get('fire_count', 0),
            "incident_dates": fire_history.get('fire_dates', []),
            "recent_activity": "Yes" if fire_history.get('fire_count', 0) > 0 else "No historical fires recorded",
            "fire_frequency": self._calculate_fire_frequency(fire_history.get('fire_dates', []))
        }
    
    def _calculate_fire_frequency(self, fire_dates: List[str]) -> str:
        """Calculate fire frequency"""
        if not fire_dates:
            return "No historical data"
        
        try:
            # Simple frequency calculation
            years_with_fires = len(set(date.split('/')[-1] for date in fire_dates if '/' in date))
            if years_with_fires <= 1:
                return "Isolated incidents"
            elif years_with_fires <= 3:
                return "Infrequent"
            else:
                return "Recurring pattern"
        except:
            return "Unable to determine"
    
    def _extract_risk_factors(self, reasoning: str) -> List[str]:
        """Extract risk factors from AI reasoning"""
        risk_keywords = {
            'temperature': ['temperature', 'heat', 'hot'],
            'humidity': ['humidity', 'dry', 'moisture'],
            'wind': ['wind', 'gusts', 'breeze'],
            'detection': ['fire', 'smoke', 'detection', 'camera'],
            'weather': ['weather', 'conditions', 'climate']
        }
        
        factors = []
        reasoning_lower = reasoning.lower()
        
        for category, keywords in risk_keywords.items():
            if any(keyword in reasoning_lower for keyword in keywords):
                factors.append(category.title())
        
        return factors if factors else ["General risk assessment"]
    
    def _generate_monitoring_recommendations(self, risk_score: int) -> List[str]:
        return []
        
    def _generate_resource_recommendations(self, risk_score: int, fire_stations: Dict) -> List[str]:
        """Generate resource deployment recommendations"""
        recommendations = []
        
        # Add specific fire station information
        stations_detail = fire_stations.get('stations_detail', [])
        if stations_detail:
            nearest = stations_detail[0]
            name = nearest.get('name', 'Unknown')
            distance_km = nearest.get('distance_km', 'N/A')
            distance_mi = nearest.get('distance_mi', 'N/A')
    
            recommendations.append(f"Primary response: {name} ({distance_km}km / {distance_mi}mi)")
        
        return recommendations
    
    def _format_fire_stations(self, fire_stations: Dict) -> Dict:
        """Format fire station information"""
        stations_detail = fire_stations.get('stations_detail', [])
        
        formatted_stations = []
        for station in stations_detail:
            formatted_station = {
                "name": station.get('name', 'Unknown'),
                "distance": {
                    "kilometers": f"{station.get('distance_km', 'N/A')} km",
                    "miles": f"{station.get('distance_mi', 'N/A')} miles"
                },
                "location": station.get('location', 'Unknown')
            }
            formatted_stations.append(formatted_station)
        
        return {
            "total_stations": fire_stations.get('station_count', 0),
            "coverage_summary": self._generate_coverage_summary(stations_detail),
            "station_details": formatted_stations
        }
    
    def _categorize_response_distance(self, distance_km: float) -> str:
        """Categorize response distance"""
        try:
            distance = float(distance_km)
            if distance <= 5:
                return "Immediate response (<5km)"
            elif distance <= 15:
                return "Rapid response (5-15km)"
            elif distance <= 30:
                return "Standard response (15-30km)"
            else:
                return "Extended response (>30km)"
        except:
            return "Unknown response time"
    
    def _generate_coverage_summary(self, stations: List[Dict]) -> str:
        """Generate coverage summary"""

        if not stations:
            return "No fire stations in range"
        
        distances = []
        for station in stations:
            try:
                distances.append(float(station.get('distance_km', float('inf'))))
            except:
                continue
        
        if not distances:
            return "Unable to determine coverage"
        
        min_distance = min(distances)
        if min_distance <= 20:
            return "Excellent coverage - immediate response available"
        elif min_distance <= 40:
            return "Good coverage - rapid response available" 
        else:  # >40km (including 100km)
            return "Limited coverage - extended response time"
    
    def save_json_report(self, report_dict: Dict, filename: str = None) -> str:
        """
        Save JSON format report
        
        Args:
            report_dict: Report dictionary
            filename: File name (optional)
            
        Returns:
            Saved file path
        """
        if filename is None:
            location = report_dict.get('executive_summary', {}).get('location', 'Unknown')
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f'fire_risk_assessment_{location.replace(" ", "")}_{timestamp}.json'
        
        file_path = os.path.join(self.output_dir, filename)

        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(report_dict, f, ensure_ascii=False, indent=2, default=self._json_serializer)
            
            logger.info(f"JSON report saved to: {file_path}")
            return file_path
            
        except Exception as e:
            logger.error(f"Failed to save JSON report: {str(e)}")
            return ""

    def _json_serializer(self, obj):
        """Handle JSON serialization of numpy types"""
        import numpy as np
        if isinstance(obj, np.floating):
            return float(obj)
        elif isinstance(obj, np.integer):
            return int(obj)
        elif hasattr(obj, 'item'):
            return obj.item()
        raise TypeError(f"Object of type {type(obj)} is not JSON serializable")
    
    def generate_complete_report(self, assessment_result: Dict, model_name: str = "llama3.1:latest") -> str:
        """
        Generate complete fire risk assessment report (JSON format only)
        
        Args:
            assessment_result: AI assessment result
            model_name: AI model name
            
        Returns:
            JSON file path
        """
        logger.info("Starting fire risk assessment report generation...")
        
        # Generate technical report
        report_dict = self.generate_technical_report(assessment_result, model_name)
        
        # Save JSON format
        json_file = self.save_json_report(report_dict)
        
        logger.info(f"Report generation completed: JSON={json_file}")
        
        return json_file